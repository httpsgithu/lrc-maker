{"version":3,"file":"lrc-parser.js","sourceRoot":"","sources":["../node_modules/@lrc-maker/lrc-parser/src/lrc-parser.ts"],"names":[],"mappings":"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","sourcesContent":["export type Fixed = 0 | 1 | 2 | 3;\n\nexport interface ILyric {\n    time?: number;\n    text: string;\n}\n\nexport type State = Readonly<{\n    info: Map<string, string>;\n    lyric: readonly ILyric[];\n}>;\n\nexport type TrimOptios = Partial<{\n    trimStart: boolean;\n    trimEnd: boolean;\n}>;\n\nexport const parser = (lrcString: string, option: TrimOptios = {}): State => {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    const { trimStart = false, trimEnd = false } = option;\n\n    const lines = lrcString.split(/\\r\\n|\\n|\\r/u);\n\n    const timeTag = /\\[\\s*(\\d{1,3}):(\\d{1,2}(?:[:.]\\d{1,3})?)\\s*]/g;\n    const infoTag = /\\[\\s*(\\w{1,6})\\s*:(.*?)]/;\n\n    const info = new Map<string, string>();\n    const lyric: ILyric[] = [];\n\n    for (const line of lines) {\n        if (line[0] !== \"[\") {\n            lyric.push({\n                text: line,\n            });\n            continue;\n        }\n\n        // now, line starts with \"[\"\n        timeTag.lastIndex = 0;\n        const rTimeTag = timeTag.exec(line);\n        if (rTimeTag !== null) {\n            const mm = Number.parseInt(rTimeTag[1], 10);\n            const ss = Number.parseFloat(rTimeTag[2].replace(\":\", \".\"));\n            const text = line.slice(timeTag.lastIndex);\n\n            lyric.push({\n                time: mm * 60 + ss,\n                text,\n            });\n\n            continue;\n        }\n\n        const rInfoTag = infoTag.exec(line);\n        if (rInfoTag !== null) {\n            const value = rInfoTag[2].trim();\n\n            if (value === \"\") {\n                continue;\n            }\n\n            info.set(rInfoTag[1], value);\n\n            continue;\n        }\n\n        // if we reach here, it means this line starts with \"[\",\n        // but not match time tag or info tag.\n\n        lyric.push({\n            text: line,\n        });\n    }\n\n    if (trimStart || trimEnd) {\n        lyric.forEach((line) => {\n            if (trimStart) {\n                line.text = line.text.trimStart();\n            }\n            if (trimEnd) {\n                line.text = line.text.trimEnd();\n            }\n        });\n    }\n\n    return { info, lyric };\n};\n\nconst storedFormatter = new Map<Fixed, Intl.NumberFormat>();\n\nconst getFormatter = (fixed: Fixed) => {\n    if (storedFormatter.has(fixed)) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return storedFormatter.get(fixed)!;\n    }\n    const newFormatter = new Intl.NumberFormat(\"en\", {\n        minimumIntegerDigits: 2,\n        minimumFractionDigits: fixed,\n        maximumFractionDigits: fixed,\n        useGrouping: false,\n    });\n    storedFormatter.set(fixed, newFormatter);\n    return newFormatter;\n};\n\nexport const convertTimeToTag = (time: number | undefined, fixed: Fixed, withBrackets = true): string => {\n    if (time === undefined) {\n        return \"\";\n    }\n\n    const formatter = getFormatter(fixed);\n\n    const mm = Math.floor(time / 60)\n        .toString()\n        .padStart(2, \"0\");\n    const ss = formatter.format(time % 60);\n\n    return withBrackets ? `[${mm}:${ss}]` : `${mm}:${ss}`;\n};\n\nexport const formatText = (text: string, spaceStart: number, spaceEnd: number): string => {\n    let newText = text;\n    if (spaceStart >= 0) {\n        newText = \" \".repeat(spaceStart) + newText.trimStart();\n    }\n    if (spaceEnd >= 0) {\n        newText = newText.trimEnd() + \" \".repeat(spaceEnd);\n    }\n    return newText;\n};\n\nexport interface IFormatOptions {\n    spaceStart: number;\n    spaceEnd: number;\n    fixed: Fixed;\n    endOfLine?: \"\\n\" | \"\\r\\n\" | \"\\r\";\n}\n\nexport const stringify = (state: State, option: IFormatOptions): string => {\n    const { spaceStart, spaceEnd, fixed, endOfLine = \"\\r\\n\" } = option;\n\n    const infos = Array.from(state.info.entries()).map(([name, value]) => {\n        return `[${name}: ${value}]`;\n    });\n\n    const lines = state.lyric.map((line) => {\n        if (line.time === undefined) {\n            return line.text;\n        }\n        const text = formatText(line.text, spaceStart, spaceEnd);\n\n        return `${convertTimeToTag(line.time, fixed)}${text}`;\n    });\n    return infos.concat(lines).join(endOfLine);\n};\n"]}